## 一 微服务的容错模式

#### 1.0 微服务的风险

微服务之间使用轻量级的网络协议通信，通常是 REST岛l 风格的远程调用 。 由于服务与服务的调用不再是进程内的调用，而是通过网络进行的远程调用，众所周知，网络通信是不稳定、不可靠 的， 一个服务依赖的服务可能出错、超时或者窑机，如果没有及时发现和隔离问题，或者在设计中没有考虑如何应对这样的问题，那么很可能在短时间内服务的线程池中的线程被用满 、 资源耗尽，导致出现雪崩效应 。   

为了保证可用性，常用容错模式如下：
- 服务隔离模式
- 线程隔离
- 熔断模式
- 限流模式
- 失效转移模式

#### 1.1 服务隔离模式

即服务间隔离，某些服务出现错误，其他服务的影响被隔离。 

常用方案一：微服务容器分组

示例一：
  > 将微服务的每个节点的服务池分为三组：准生产环境、灰度环境和生产环境 。 准生产环境供内侧使用；灰度环境会跑一些普通商户的流量 ： 大部分生产流量和 VIP 商户的流量则跑在生产环境中 。 这样，在一次比较大的重构过程中，我们就可以充分利用灰度环境的隔离性进行预验证，用普通商户的流量验证重构没有问题后，再上生产环境。  
示例二：
  > 一些社交平台将名人的自媒体流量全部路由到服务的核心池子中，而将普通用户的流量路由到另外一个服务池子中，有效隔离了普通用户和重要用户的负载 。

![](/../images/arch/04-129.png)

#### 1.2 线程隔离

在微服务架构实施的过程中，我们不一定将每个服务拆分到微小的力度，这取决于职能团队和财务的状况，我们一般会将同一类功能划分在一个微服务中，尽量避免微服务过细而导致成本增加，适可而止。  

这样就会导致多个功能混合部署在一个微服务实例中，这些微服务的不同功能通常使用同一个线程池，导致一个功能流量增加时耗尽线程池的线程，而阻塞其他功能的服务。  

![](/../images/arch/04-130.png)  

#### 1.3 熔断模式

可以用家里的电路保险开关来比喻熔断模式，如果家里的用电量过大，则电路保险开关就会自动跳闸 ， 这时需要人工找到用电量过大的电器来解决问题，然后打开电路保险开关。在这这过程中，电路保险开关起到保护整个家庭电路系统的作用 。  

对于微服务系统也一样，当服务的输入负载迅速增加时 ， 如果没有有效的措施对负载进行熔断，则会使服务迅速被压垮，服务被压垮会导致依赖的服务都被压垮，出现雪崩效应，因此，可通过模拟家庭的电路保险开关，在微服务架构中实现熔断模式。  


![](/../images/arch/04-131.png)  

#### 1.4 限流模式

针对服务突然上量，我们必须有限流机制，限流机制一般会控制访问的井发量，例如每秒允许处理的并发用户数及查询量、请求量等。  

三种实现限流方式：
- 方式一：计数器。通过原子变量计算单位时间内的访问次数，如果超出某个阑值，则拒绝后续的请求， 等到下一个单位时间再重新计数。  
- 方式二：令牌桶  
- 方式三：信号量

计数器：定义一个循环数组，例如定义5个元素的环形数组，计数周期为1s，可以记录4s内的访问量，其中有1个元素为当前时间点的标志，每秒程序都会将前面3秒的访问量打印到日志。

![](/../images/arch/04-132.png)   

将时间的秒数除以数组元素的个数 5 ，然后取模，映射到环形数组里的数据元素，假如当前时间是 1 000 000 002s，那么对应当前时间的环形数组里的第 3 个元素，下标为 2，此时的数组元素的数据如图：  

![](/../images/arch/04-133.png)   

上图中，当前时间为 l 000 000 002s，对应的计数器在第 3 个元素，下标为 2 ， 当前请求是在这个时间周期内的第 l 个访问请求，程序首先需要对后一个元素即第 4 个元素，也就是下标为 3 的元素清零；在 l 000 000 002s 内，任何一个请求如果发现下标为 3 的元素不为 0，则都会将原子变量 3 清零 ， 并记录清零的时间 。  

这时程序可以对第 3 个元素即下标为 2 的元素，进行累加井判断是否达到阁值，如果达到阁值 ， 则拒绝请求，否则请求通过；同时，打印本次及之前 3 秒的数据访问量，打印结果如下 ：
```
当前： l 次 ， 前 ls: 302 次，前 2s: 201 次，前 3s: 518 次
```

然而，如果当前秒一直没有请求量，下一秒的计数器始终不能清零，则下一秒的请求到达后要首先清零再使用，井更新清零时间 。在下一秒的请求到达后，若检查到当前秒对应的原子变量计数器不为 0，而且最后的清零时间不是上一秒，则先对当前秒的计数器清零，再进行累加操作，这避免发生上一秒无请求的场景，或者上一秒的请求由于线程调度延迟而没有清零下一秒的场景，后面这种场景发生的概率较小 。  

另外一种实现计数器的简单方法是单独启动一个线程，每隔一定的时间间隔执行对下一秒的原子变量计数器清零操作，这个时间间隔必须小于计数时间间隔。  
令牌桶方案：  
令牌筒是一个流行的实现限流的技术方案，它通过一个线程在单位时间内生产固定数量的令牌 ， 然后把令牌放入队列，每次请求调用需要从桶中拿取一个令牌，拿到令牌后才有资格执行请求调用， 否则只 能等待拿到令牌再执行，或者直接丢弃。  

![](/../images/arch/04-134.png)   

信号量方案：  

信号量类似于现实中漏油，无论油有多少，漏管的出口永远是优先的。  

```java
public class SemaphoreExample {
    private ExecutorService exec= Executors . newCachedThreadPool() ;
    public static vo 工d main(String[] args) {
        final Semaphore sem =new Semaphore(S);
        for (int index = 0; index < 20 ; index++) {
            Runnable run= new Runnable() {
                public void run() {
                    try {
                        ／／获得许可
                        sem. acquire();
                        ／／同时只有 5 个请求可以到达这里
                        Thread . sleep( (long) (Math.random()));
                        ／／释放许可
                        sem .release();
                        System .out.println （ ”剩余许可：” ＋ sem . availablePermits() ) ;
                    } catch (InterruptedException e) {
                        e.printStackTrace() ;
                    }
                }
            };
            exec . execute(run) ;
        }
        exec.shutdown() ;
    }
}
```




#### 1.5 失效转移模式

若微服务架构中发生了熔断和限流，则该如何处理被拒绝的请求呢？解决这个问题的模式叫作失效转移模式，通常分为下面几种：
- 采用快速失败的策略，直接返回使用方错误，让使用方知道发生了问题并自行决定后续处理。
- 是否有备份服务，如果有备份服务，则迅速切换到备份服务。
- 失败的服务有可能是某台机器有问题，而不是所有机器有问题，例如 OOM 问题，在这种情况下适合使用 failover 策略，采用重试的方法来解决 ， 但是这种方法要求服务提供者的服务实现了幕等性。